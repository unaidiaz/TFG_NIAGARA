#ifndef EMITTER_H
#define EMITTER_H
#include <list>
#include <math.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include"GeneralTextureAnimation.h"
#include"Particle.h"
#include"Camera.h"
#include"Object.h"
#include"Physics.h"
#include"imgui.h"
#include "imgui_gradient/include/imgui_gradient/imgui_gradient.hpp"
enum class emitterState {
    PLAY,
    STOP
};
enum class spawnForms {
    CUSTOM,
    CONE,
    SPHERE
};
class Emitter {
public:
    Emitter();
    ~Emitter();
    void PreUpdate(float dt);
    void Update(float dt);
    void PostUpdate(float dt);
    void LoadGeometry(std::list<float> Vertices, std::list<unsigned int> Indices, const char* VertexShaderSource, const char* FragmentShaderSource, const char* path);
    void SetCamera(Camera* camera);
    void addParticle();
    void substractParticle(int number);
    void initNewParticle(int cant);


    float* vertices;
    unsigned int* indices;
    Shader* ourShader;
    bool isSecondary = false;
    bool instancing = false;
    float ppspdp = 0;
    int cant = 50000;
    glm::mat4* modelMatrices;
    glm::vec4* color;
    GLuint VBO;
    GLuint EBO;
    GLuint VAO;

    GLuint col;
    GLuint buffer;
    GLuint texture;
private:
    //UPDATE FUNCTIONS
    emitterState generalState;
    void instancedRender();

    void UpdateScale(particle* auxiliar);
    void UpdateRotation(particle* auxiliar,float dt);
    void UpdatePhysics(particle* auxiliar, float dt);
    void UpdateAlphaAndColor(particle* auxiliar);
    void UpdateTextures(particle* auxiliar, float dt);
    void UpdateSecondariEmitters(int time,particle* auxiliar);
    
    void UpdateTransformEfects(particle* auxiliar, float dt);
    //
    std::string emmitterName="emitter";
    void ResetSimulation();
    void particleSpawn(particle* auxiliar);
    float GetZeroOneConvertion(float actualValue, float maxValue);
    void OnEditor(float dt);
    void Draw(particle* auxiliar);
    object* geometry;
    particle* activeNewParticle();
    bool faceToCamera;
    
private:
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Imgui
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    bool showEdit = true;
    ImVec2 graphicSize = { 500,200 };

    std::list<particle*> allParticles;
    std::list<particle*> activeParticles;
    glm::vec3 position;
    int maxParticles;
    int lastMaxParticles;

    bool loop = true;
    float emitterMaxLifetime = 10;
    float emitteractuallifetime = 0;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Efects
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int transformEfect = 0;
    const char* transformEfects[2];
    
    //CAMERA
    Camera* camera;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //TectureAnimation
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    GeneralTextureAnimation* textureAnimation;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Rotation variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    glm::vec3 auxiliarRotationAxis;
    glm::vec3 AllAxisRotationVelocitys;
    float auxiliarRotationAngle;
    void setGeneralRotationaxis(glm::vec3 axis, float newAngle);
    
    float rotationVelocity;
    Physics* physicsModule;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Life time variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int LifeTimeItem = 0;
    const char* LifeTimeItems[2];
    float maxParticleLifeTime;
    float lifeRandomScope[2];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Time variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    float auxiliarTimefrecuency;
    float spawnFrec;
    float acumulationTime;
    float prevTimeValue;
    float lastTimeValue;


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Spawn Position Variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int positionItem = 0;
    const char* positionItems[2];
    glm::vec3 spawnPosition;
    float XPositionRandomScope[2];
    float YPositionRandomScope[2];
    float ZPositionRandomScope[2];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Spawn velocity Variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    glm::vec3 spawnVelocity;
    int velocityItem = 0;
    const char* velocityItems[2];
    float XVelocityRandomScope[2];
    float YVelocityRandomScope[2];
    float ZVelocityRandomScope[2];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Spawn aceleration Variables
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    glm::vec3 spawnAceleration;
    glm::vec2 XAcelerationRandomScope;
    glm::vec2 YAcelerationRandomScope;
    glm::vec2 ZAcelerationRandomScope;
    bool isAcelerationXrandom = false;
    bool isAcelerationYrandom = false;
    bool isAcelerationZrandom = false;

    inline glm::vec3 GetPosition() { return position; }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Textures
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int Textureitem = 0;
    const char* textureItems[3];
    int fixedIDToSet = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Scale
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float spawnScale;
    int Scaleitem = 0;
    const char* scaleItems[3];
    ImVec2 graphicScalePoints[4];
    float maxScale = 1;
    float scaleRandomScope[2];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Alpha
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    bool alphaModified;
    int Alphaitem = 2;
    const char* alphaItems[3];
    ImVec2 graphicAlphaPoints[4];
    float ParticlesColorAndAlpha[4];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //color
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int Coloritem = 0;
    const char* colorItems[3];
    ImGG::GradientWidget gradient_widget{};
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //prefabricated spawn forms
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    int actualForm = 0;
    const char* spawnForms[3];

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //particle partition
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    int actualPartition = 0;
    const char* PartitionMode[2];
    int actualRandomPartition = 0;
    const char* randomPartitionMode[2];
    int fixedNmOfPartitions = 0;
    int NmOfPartitionsRandomScope[2];
    float probabilityofPartition = 0;

    void partitionWindow();
    bool showPartitionWindow =false;
    std::list<Emitter*> SecondEmitters;
    float exlosionTime;
    float prevExlosionTime;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //vortex
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    float actualSinVaule=90;
    int conversor = 1;
    void UpdateVortex(particle* auxiliar, float dt);

    bool Xvortex = false;
    float XVortexRadius=1;
    float XVortexVelocity = 1;

    bool Yvortex = false;
    float YVortexRadius = 1;
    float YVortexVelocity = 1;

    bool Zvortex = false;
    float ZVortexRadius = 1;
    float ZVortexVelocity = 1;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //pyhsics
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char* massMode[2];
    int actualMassMode = 0; 
    float massRandomScope[2];
    float fixedMass=1;

    const char* radiusMode[2];
    int actualRadiusMode = 0;
    float radiusRandomScope[2];
    float fixedRadius=1;
};
#endif
